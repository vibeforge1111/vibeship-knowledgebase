# AI Tool Vulnerability Patterns

Known security patterns generated by each AI coding tool. Use this reference when writing tool-specific content.

## Cursor

### Profile
- **Type:** VS Code extension with AI integration
- **Primary Model:** GPT-4, Claude (configurable)
- **Strengths:** Fast generation, good context understanding
- **Security Weakness:** Prioritizes working code over secure code

### Top Vulnerability Patterns

#### 1. SQL Injection via Template Literals
**Prevalence:** 81% of projects

Cursor defaults to template literals for SQL because they're readable:

```javascript
// Cursor generates this
const getUser = async (userId) => {
  const result = await db.query(`
    SELECT * FROM users WHERE id = ${userId}
  `)
  return result.rows[0]
}
```

**Why:** Template literals are Cursor's preferred string format. When generating database code, it uses them by default without considering injection risks.

#### 2. Missing Authentication on API Routes
**Prevalence:** 68% of projects

Cursor creates functional routes without auth checks:

```javascript
// Cursor generates this
// pages/api/users/[id].ts
export default async function handler(req, res) {
  const { id } = req.query
  const user = await prisma.user.findUnique({ where: { id } })
  res.json(user)
}
```

**Why:** When asked to "create an API route to get user," Cursor delivers exactly that—without considering that authentication might be needed.

#### 3. Hardcoded API Keys
**Prevalence:** 73% of projects

Cursor includes example values that become real code:

```javascript
// Cursor generates this when you ask for Stripe integration
const stripe = new Stripe('sk_test_EXAMPLE_KEY_REPLACE_ME', {
  apiVersion: '2023-10-16'
})
```

**Why:** Cursor often generates "example" code with placeholder values that developers forget to replace.

#### 4. Client-Side Secret Exposure
**Prevalence:** 45% of projects

Cursor sometimes puts server-only code in client components:

```javascript
// Cursor generates this in a React component
const supabase = createClient(
  'https://xyzcompany.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...' // Service role key!
)
```

**Why:** When context isn't clear, Cursor may not distinguish between client and server code.

---

## Claude Code

### Profile
- **Type:** Anthropic's official coding agent
- **Primary Model:** Claude 3.5 Sonnet
- **Strengths:** Thoughtful, considers context, asks questions
- **Security Weakness:** Sometimes over-trusts user input

### Top Vulnerability Patterns

#### 1. Missing Input Validation
**Prevalence:** 72% of projects

Claude Code trusts user-provided data:

```javascript
// Claude Code generates this
app.post('/api/profile', async (req, res) => {
  const { name, email, role } = req.body
  // No validation that 'role' should be user-controlled
  await db.user.update({
    where: { id: req.user.id },
    data: { name, email, role }
  })
  res.json({ success: true })
})
```

**Why:** Claude focuses on fulfilling the request. If you ask for "an endpoint to update profile," it provides one—even if that means accepting role changes.

#### 2. Authorization Logic Gaps
**Prevalence:** 58% of projects

Claude Code checks authentication but misses authorization:

```javascript
// Claude Code generates this
app.get('/api/documents/:docId', authenticate, async (req, res) => {
  // Checks that user is logged in, but not that they own this document
  const doc = await db.document.findUnique({
    where: { id: req.params.docId }
  })
  res.json(doc)
})
```

**Why:** Claude distinguishes authentication from authorization but doesn't always implement both unless specifically asked.

#### 3. Verbose Error Messages
**Prevalence:** 41% of projects

Claude Code provides helpful but dangerous error details:

```javascript
// Claude Code generates this
try {
  await db.user.create({ data: userData })
} catch (error) {
  res.status(500).json({
    error: error.message,
    stack: error.stack,  // Exposes internal details
    query: error.query   // Exposes database structure
  })
}
```

**Why:** Claude's tendency to be helpful extends to error handling—it wants to provide useful debugging info.

#### 4. Insecure Default CORS
**Prevalence:** 38% of projects

```javascript
// Claude Code generates this for "add CORS support"
app.use(cors({
  origin: '*',  // Too permissive
  credentials: true
}))
```

**Why:** When asked to "enable CORS," Claude provides a working solution. The most permissive option always works.

---

## Bolt

### Profile
- **Type:** StackBlitz's AI coding tool
- **Primary Model:** Various (Claude, GPT)
- **Strengths:** Quick prototypes, full-stack generation
- **Security Weakness:** Speed over security, minimal validation

### Top Vulnerability Patterns

#### 1. Hardcoded Credentials in Generated Projects
**Prevalence:** 89% of projects

Bolt generates complete projects with embedded secrets:

```javascript
// Bolt generates this in its boilerplate
// .env.local (but sometimes in actual code)
const config = {
  supabaseUrl: 'https://abcdefgh.supabase.co',
  supabaseKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',
  stripeKey: 'sk_live_...'
}
```

**Why:** Bolt generates "ready to run" projects. To be immediately functional, it includes credentials.

#### 2. Missing Rate Limiting
**Prevalence:** 94% of projects

Bolt rarely adds rate limiting:

```javascript
// Bolt generates this - no rate limiting
app.post('/api/login', async (req, res) => {
  const { email, password } = req.body
  const user = await verifyCredentials(email, password)
  // Unlimited login attempts possible
})
```

**Why:** Rate limiting isn't essential for a working demo. Bolt optimizes for "does it work?" not "is it secure?"

#### 3. SQL Queries in Frontend Code
**Prevalence:** 52% of projects

Bolt sometimes puts database access in client components:

```javascript
// Bolt generates this in a React component
const [users, setUsers] = useState([])

useEffect(() => {
  const { data } = await supabase
    .from('users')
    .select('*')  // Fetches all users from client side
  setUsers(data)
}, [])
```

**Why:** For quick demos, client-side data fetching is simpler. Bolt doesn't always create proper API routes.

#### 4. Disabled Security Features
**Prevalence:** 47% of projects

Bolt sometimes disables security for convenience:

```javascript
// Bolt generates this in Next.js
// next.config.js
module.exports = {
  eslint: { ignoreDuringBuilds: true },
  typescript: { ignoreBuildErrors: true },
  // Sometimes even:
  experimental: { serverActions: true }
}
```

**Why:** Security warnings slow down prototyping. Bolt prioritizes getting something working.

---

## v0 (Vercel)

### Profile
- **Type:** Vercel's UI generation tool
- **Primary Model:** GPT-4
- **Strengths:** Beautiful UI components, React/Next.js focus
- **Security Weakness:** UI-focused, backend security secondary

### Top Vulnerability Patterns

#### 1. Missing Server-Side Validation
**Prevalence:** 76% of projects

v0 generates client-side validation only:

```javascript
// v0 generates this
function ContactForm() {
  const [email, setEmail] = useState('')
  
  const handleSubmit = async (e) => {
    e.preventDefault()
    if (!email.includes('@')) {  // Client-only validation
      return alert('Invalid email')
    }
    await fetch('/api/contact', {
      method: 'POST',
      body: JSON.stringify({ email })
    })
  }
}
```

**Why:** v0 focuses on UI/UX. Validation is implemented where it's visible—in the frontend.

#### 2. Exposed Server Actions
**Prevalence:** 63% of projects

v0 uses Next.js server actions without proper guards:

```javascript
// v0 generates this
'use server'

export async function deleteUser(userId: string) {
  // No auth check - any client can call this
  await db.user.delete({ where: { id: userId } })
}
```

**Why:** Server actions are convenient for forms. v0 uses them liberally without auth checks.

#### 3. Client-Side Secret Usage
**Prevalence:** 41% of projects

v0 sometimes exposes environment variables:

```javascript
// v0 generates this
const apiKey = process.env.NEXT_PUBLIC_API_KEY  // Exposed to client
// or worse:
const secretKey = process.env.SECRET_KEY  // Bundled in client code
```

**Why:** Environment variable handling in Next.js is confusing. v0 doesn't always get it right.

---

## Replit

### Profile
- **Type:** Online IDE with AI assistant
- **Primary Model:** Various
- **Strengths:** Instant deployment, collaborative
- **Security Weakness:** Development patterns in production

### Top Vulnerability Patterns

#### 1. Debug Mode in Production
**Prevalence:** 67% of projects

Replit projects often ship with debug enabled:

```python
# Replit generates this
app = Flask(__name__)
app.config['DEBUG'] = True  # Left on in production

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True)
```

**Why:** Debug mode makes development easier. Replit projects are "always in development."

#### 2. Exposed Database URLs
**Prevalence:** 58% of projects

Replit's secrets management is sometimes bypassed:

```javascript
// Replit generates this
const mongoose = require('mongoose')
mongoose.connect('mongodb+srv://user:password@cluster.mongodb.net/db')
```

**Why:** Replit has a secrets manager, but AI doesn't always use it.

#### 3. Missing HTTPS Enforcement
**Prevalence:** 73% of projects

Replit apps often don't enforce HTTPS:

```javascript
// Replit generates this - no HTTPS redirect
app.listen(3000, () => {
  console.log('Server running on port 3000')
})
```

**Why:** Replit's development URLs are HTTP. Production security isn't default.

---

## GitHub Copilot

### Profile
- **Type:** GitHub's AI pair programmer
- **Primary Model:** OpenAI Codex/GPT
- **Strengths:** Context-aware, learns from your code
- **Security Weakness:** Reproduces patterns from training data

### Top Vulnerability Patterns

#### 1. Outdated Security Patterns
**Prevalence:** 45% of projects

Copilot sometimes suggests deprecated approaches:

```javascript
// Copilot generates this
const crypto = require('crypto')
const hash = crypto.createHash('md5').update(password).digest('hex')
// MD5 is broken for passwords
```

**Why:** Copilot learned from historical code. Old patterns persist in suggestions.

#### 2. Pattern Propagation
**Prevalence:** 62% of projects

If your codebase has one vulnerability, Copilot spreads it:

```javascript
// If you have this somewhere
const user = await db.query(`SELECT * FROM users WHERE id = ${id}`)

// Copilot will generate more like it
const order = await db.query(`SELECT * FROM orders WHERE user_id = ${userId}`)
const product = await db.query(`SELECT * FROM products WHERE id = ${productId}`)
```

**Why:** Copilot uses your code as context. Vulnerable patterns become templates.

#### 3. Comment-Driven Vulnerabilities
**Prevalence:** 38% of projects

```javascript
// Copilot completes this comment literally
// TODO: disable auth for testing
const authMiddleware = (req, res, next) => next()  // Bypasses auth
```

**Why:** Copilot tries to fulfill comments. Dangerous comments get dangerous completions.

---

## Common Patterns Across All Tools

### 1. Missing Input Validation
All AI tools trust user input more than they should.

### 2. Authentication Without Authorization
Tools check IF you're logged in but not WHAT you can access.

### 3. Development Defaults in Production
Debug modes, verbose errors, permissive CORS.

### 4. Secret Management Failures
Hardcoded keys, exposed environment variables, client-side secrets.

### 5. SQL/NoSQL Injection
String concatenation in queries, especially with template literals.

---

## Prompts That Improve Security

### For Any Tool

**Instead of:** "Create a login system"
**Say:** "Create a secure login system with:
- Password hashing using bcrypt with cost factor 12
- Rate limiting (max 5 attempts per 15 minutes)
- Parameterized database queries
- HTTPS-only session cookies
- CSRF protection"

**Instead of:** "Add a database query"
**Say:** "Add a parameterized database query that:
- Uses prepared statements, not string concatenation
- Validates input types before querying
- Returns only necessary fields, not SELECT *
- Handles errors without exposing query details"

**Instead of:** "Create an API endpoint"
**Say:** "Create an API endpoint with:
- Authentication middleware
- Authorization check (user can only access their own data)
- Input validation and sanitization
- Rate limiting
- Proper error handling (no stack traces)"
